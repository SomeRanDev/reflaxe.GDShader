package gdshader.types;

import gdshader.types.*;

@:copyValue
@:noCompletion
@:avoidTemporaries
@:gdshaderType("vec3")
extern class Vec3Inner {
	var x: Float;
	var y: Float;
	var z: Float;
	var xx: Vec2;
	var xy: Vec2;
	var xz: Vec2;
	var yx: Vec2;
	var yy: Vec2;
	var yz: Vec2;
	var zx: Vec2;
	var zy: Vec2;
	var zz: Vec2;
	var xxx: Vec3;
	var xxy: Vec3;
	var xxz: Vec3;
	var xyx: Vec3;
	var xyy: Vec3;
	var xyz: Vec3;
	var xzx: Vec3;
	var xzy: Vec3;
	var xzz: Vec3;
	var yxx: Vec3;
	var yxy: Vec3;
	var yxz: Vec3;
	var yyx: Vec3;
	var yyy: Vec3;
	var yyz: Vec3;
	var yzx: Vec3;
	var yzy: Vec3;
	var yzz: Vec3;
	var zxx: Vec3;
	var zxy: Vec3;
	var zxz: Vec3;
	var zyx: Vec3;
	var zyy: Vec3;
	var zyz: Vec3;
	var zzx: Vec3;
	var zzy: Vec3;
	var zzz: Vec3;
	var xxxx: Vec4;
	var xxxy: Vec4;
	var xxxz: Vec4;
	var xxyx: Vec4;
	var xxyy: Vec4;
	var xxyz: Vec4;
	var xxzx: Vec4;
	var xxzy: Vec4;
	var xxzz: Vec4;
	var xyxx: Vec4;
	var xyxy: Vec4;
	var xyxz: Vec4;
	var xyyx: Vec4;
	var xyyy: Vec4;
	var xyyz: Vec4;
	var xyzx: Vec4;
	var xyzy: Vec4;
	var xyzz: Vec4;
	var xzxx: Vec4;
	var xzxy: Vec4;
	var xzxz: Vec4;
	var xzyx: Vec4;
	var xzyy: Vec4;
	var xzyz: Vec4;
	var xzzx: Vec4;
	var xzzy: Vec4;
	var xzzz: Vec4;
	var yxxx: Vec4;
	var yxxy: Vec4;
	var yxxz: Vec4;
	var yxyx: Vec4;
	var yxyy: Vec4;
	var yxyz: Vec4;
	var yxzx: Vec4;
	var yxzy: Vec4;
	var yxzz: Vec4;
	var yyxx: Vec4;
	var yyxy: Vec4;
	var yyxz: Vec4;
	var yyyx: Vec4;
	var yyyy: Vec4;
	var yyyz: Vec4;
	var yyzx: Vec4;
	var yyzy: Vec4;
	var yyzz: Vec4;
	var yzxx: Vec4;
	var yzxy: Vec4;
	var yzxz: Vec4;
	var yzyx: Vec4;
	var yzyy: Vec4;
	var yzyz: Vec4;
	var yzzx: Vec4;
	var yzzy: Vec4;
	var yzzz: Vec4;
	var zxxx: Vec4;
	var zxxy: Vec4;
	var zxxz: Vec4;
	var zxyx: Vec4;
	var zxyy: Vec4;
	var zxyz: Vec4;
	var zxzx: Vec4;
	var zxzy: Vec4;
	var zxzz: Vec4;
	var zyxx: Vec4;
	var zyxy: Vec4;
	var zyxz: Vec4;
	var zyyx: Vec4;
	var zyyy: Vec4;
	var zyyz: Vec4;
	var zyzx: Vec4;
	var zyzy: Vec4;
	var zyzz: Vec4;
	var zzxx: Vec4;
	var zzxy: Vec4;
	var zzxz: Vec4;
	var zzyx: Vec4;
	var zzyy: Vec4;
	var zzyz: Vec4;
	var zzzx: Vec4;
	var zzzy: Vec4;
	var zzzz: Vec4;
	var r: Float;
	var g: Float;
	var b: Float;
	var rr: Vec2;
	var rg: Vec2;
	var rb: Vec2;
	var gr: Vec2;
	var gg: Vec2;
	var gb: Vec2;
	var br: Vec2;
	var bg: Vec2;
	var bb: Vec2;
	var rrr: Vec3;
	var rrg: Vec3;
	var rrb: Vec3;
	var rgr: Vec3;
	var rgg: Vec3;
	var rgb: Vec3;
	var rbr: Vec3;
	var rbg: Vec3;
	var rbb: Vec3;
	var grr: Vec3;
	var grg: Vec3;
	var grb: Vec3;
	var ggr: Vec3;
	var ggg: Vec3;
	var ggb: Vec3;
	var gbr: Vec3;
	var gbg: Vec3;
	var gbb: Vec3;
	var brr: Vec3;
	var brg: Vec3;
	var brb: Vec3;
	var bgr: Vec3;
	var bgg: Vec3;
	var bgb: Vec3;
	var bbr: Vec3;
	var bbg: Vec3;
	var bbb: Vec3;
	var rrrr: Vec4;
	var rrrg: Vec4;
	var rrrb: Vec4;
	var rrgr: Vec4;
	var rrgg: Vec4;
	var rrgb: Vec4;
	var rrbr: Vec4;
	var rrbg: Vec4;
	var rrbb: Vec4;
	var rgrr: Vec4;
	var rgrg: Vec4;
	var rgrb: Vec4;
	var rggr: Vec4;
	var rggg: Vec4;
	var rggb: Vec4;
	var rgbr: Vec4;
	var rgbg: Vec4;
	var rgbb: Vec4;
	var rbrr: Vec4;
	var rbrg: Vec4;
	var rbrb: Vec4;
	var rbgr: Vec4;
	var rbgg: Vec4;
	var rbgb: Vec4;
	var rbbr: Vec4;
	var rbbg: Vec4;
	var rbbb: Vec4;
	var grrr: Vec4;
	var grrg: Vec4;
	var grrb: Vec4;
	var grgr: Vec4;
	var grgg: Vec4;
	var grgb: Vec4;
	var grbr: Vec4;
	var grbg: Vec4;
	var grbb: Vec4;
	var ggrr: Vec4;
	var ggrg: Vec4;
	var ggrb: Vec4;
	var gggr: Vec4;
	var gggg: Vec4;
	var gggb: Vec4;
	var ggbr: Vec4;
	var ggbg: Vec4;
	var ggbb: Vec4;
	var gbrr: Vec4;
	var gbrg: Vec4;
	var gbrb: Vec4;
	var gbgr: Vec4;
	var gbgg: Vec4;
	var gbgb: Vec4;
	var gbbr: Vec4;
	var gbbg: Vec4;
	var gbbb: Vec4;
	var brrr: Vec4;
	var brrg: Vec4;
	var brrb: Vec4;
	var brgr: Vec4;
	var brgg: Vec4;
	var brgb: Vec4;
	var brbr: Vec4;
	var brbg: Vec4;
	var brbb: Vec4;
	var bgrr: Vec4;
	var bgrg: Vec4;
	var bgrb: Vec4;
	var bggr: Vec4;
	var bggg: Vec4;
	var bggb: Vec4;
	var bgbr: Vec4;
	var bgbg: Vec4;
	var bgbb: Vec4;
	var bbrr: Vec4;
	var bbrg: Vec4;
	var bbrb: Vec4;
	var bbgr: Vec4;
	var bbgg: Vec4;
	var bbgb: Vec4;
	var bbbr: Vec4;
	var bbbg: Vec4;
	var bbbb: Vec4;
	var s: Float;
	var t: Float;
	var p: Float;
	var ss: Vec2;
	var st: Vec2;
	var sp: Vec2;
	var ts: Vec2;
	var tt: Vec2;
	var tp: Vec2;
	var ps: Vec2;
	var pt: Vec2;
	var pp: Vec2;
	var sss: Vec3;
	var sst: Vec3;
	var ssp: Vec3;
	var sts: Vec3;
	var stt: Vec3;
	var stp: Vec3;
	var sps: Vec3;
	var spt: Vec3;
	var spp: Vec3;
	var tss: Vec3;
	var tst: Vec3;
	var tsp: Vec3;
	var tts: Vec3;
	var ttt: Vec3;
	var ttp: Vec3;
	var tps: Vec3;
	var tpt: Vec3;
	var tpp: Vec3;
	var pss: Vec3;
	var pst: Vec3;
	var psp: Vec3;
	var pts: Vec3;
	var ptt: Vec3;
	var ptp: Vec3;
	var pps: Vec3;
	var ppt: Vec3;
	var ppp: Vec3;
	var ssss: Vec4;
	var ssst: Vec4;
	var sssp: Vec4;
	var ssts: Vec4;
	var sstt: Vec4;
	var sstp: Vec4;
	var ssps: Vec4;
	var sspt: Vec4;
	var sspp: Vec4;
	var stss: Vec4;
	var stst: Vec4;
	var stsp: Vec4;
	var stts: Vec4;
	var sttt: Vec4;
	var sttp: Vec4;
	var stps: Vec4;
	var stpt: Vec4;
	var stpp: Vec4;
	var spss: Vec4;
	var spst: Vec4;
	var spsp: Vec4;
	var spts: Vec4;
	var sptt: Vec4;
	var sptp: Vec4;
	var spps: Vec4;
	var sppt: Vec4;
	var sppp: Vec4;
	var tsss: Vec4;
	var tsst: Vec4;
	var tssp: Vec4;
	var tsts: Vec4;
	var tstt: Vec4;
	var tstp: Vec4;
	var tsps: Vec4;
	var tspt: Vec4;
	var tspp: Vec4;
	var ttss: Vec4;
	var ttst: Vec4;
	var ttsp: Vec4;
	var ttts: Vec4;
	var tttt: Vec4;
	var tttp: Vec4;
	var ttps: Vec4;
	var ttpt: Vec4;
	var ttpp: Vec4;
	var tpss: Vec4;
	var tpst: Vec4;
	var tpsp: Vec4;
	var tpts: Vec4;
	var tptt: Vec4;
	var tptp: Vec4;
	var tpps: Vec4;
	var tppt: Vec4;
	var tppp: Vec4;
	var psss: Vec4;
	var psst: Vec4;
	var pssp: Vec4;
	var psts: Vec4;
	var pstt: Vec4;
	var pstp: Vec4;
	var psps: Vec4;
	var pspt: Vec4;
	var pspp: Vec4;
	var ptss: Vec4;
	var ptst: Vec4;
	var ptsp: Vec4;
	var ptts: Vec4;
	var pttt: Vec4;
	var pttp: Vec4;
	var ptps: Vec4;
	var ptpt: Vec4;
	var ptpp: Vec4;
	var ppss: Vec4;
	var ppst: Vec4;
	var ppsp: Vec4;
	var ppts: Vec4;
	var pptt: Vec4;
	var pptp: Vec4;
	var ppps: Vec4;
	var pppt: Vec4;
	var pppp: Vec4;
}

@:forward
@:copyValue
@:avoidTemporaries
@:gdshaderType("vec3")
extern abstract Vec3(Vec3Inner) {
	@:overload(function(x: Float, y: Float, z: Float): Void {})
	@:overload(function(vec2: Vec2, float: Float): Void {})
	@:overload(function(float: Float, vec2: Vec2): Void {})
	@:overload(function(bvec3: BVec3): Void {})
	@:overload(function(ivec3: IVec3): Void {})
	@:overload(function(uvec3: UVec3): Void {})
	@:overload(function(vec3: Vec3): Void {})
	@:native("vec3")
	public function new(float: Float);

	@:op(A == B) public static inline function equalsVec3(me: Vec3, other: Vec3): Bool return untyped __gdshader__("({0} == {1})", me, other);
	@:op(A != B) public static inline function notEqualsVec3(me: Vec3, other: Vec3): Bool return untyped __gdshader__("({0} != {1})", me, other);
	@:op(-A) public static inline function negate(me: Vec3): Vec3 return untyped __gdshader__("(-{0})", me);
	@:op(A + B) public static inline function addFloat(me: Vec3, other: Float): Vec3 return untyped __gdshader__("({0} + {1})", me, other);
	@:op(A + B) public static inline function addVec3(me: Vec3, other: Vec3): Vec3 return untyped __gdshader__("({0} + {1})", me, other);
	@:op(A - B) public static inline function subtractFloat(me: Vec3, other: Float): Vec3 return untyped __gdshader__("({0} - {1})", me, other);
	@:op(A - B) public static inline function subtractVec3(me: Vec3, other: Vec3): Vec3 return untyped __gdshader__("({0} - {1})", me, other);
	@:op(A * B) public static inline function multiplyFloat(me: Vec3, other: Float): Vec3 return untyped __gdshader__("({0} * {1})", me, other);
	@:op(A * B) public static inline function multiplyVec3(me: Vec3, other: Vec3): Vec3 return untyped __gdshader__("({0} * {1})", me, other);
	@:op(A * B) public static inline function multiplyMat3(me: Vec3, other: Mat3): Vec3 return untyped __gdshader__("({0} * {1})", me, other);
	@:op(A / B) public static inline function divideFloat(me: Vec3, other: Float): Vec3 return untyped __gdshader__("({0} / {1})", me, other);
	@:op(A / B) public static inline function divideVec3(me: Vec3, other: Vec3): Vec3 return untyped __gdshader__("({0} / {1})", me, other);
	@:op(A += B) public static inline function addAssignFloat(me: Vec3, other: Float): Vec3 return untyped __gdshader__("({0} += {1})", me, other);
	@:op(A += B) public static inline function addAssignVec3(me: Vec3, other: Vec3): Vec3 return untyped __gdshader__("({0} += {1})", me, other);
	@:op(A -= B) public static inline function subtractAssignFloat(me: Vec3, other: Float): Vec3 return untyped __gdshader__("({0} -= {1})", me, other);
	@:op(A -= B) public static inline function subtractAssignVec3(me: Vec3, other: Vec3): Vec3 return untyped __gdshader__("({0} -= {1})", me, other);
	@:op(A *= B) public static inline function multiplyAssignFloat(me: Vec3, other: Float): Vec3 return untyped __gdshader__("({0} *= {1})", me, other);
	@:op(A *= B) public static inline function multiplyAssignVec3(me: Vec3, other: Vec3): Vec3 return untyped __gdshader__("({0} *= {1})", me, other);
	@:op(A *= B) public static inline function multiplyAssignMat3(me: Vec3, other: Mat3): Vec3 return untyped __gdshader__("({0} *= {1})", me, other);
	@:op(A /= B) public static inline function divideAssignFloat(me: Vec3, other: Float): Vec3 return untyped __gdshader__("({0} /= {1})", me, other);
	@:op(A /= B) public static inline function divideAssignVec3(me: Vec3, other: Vec3): Vec3 return untyped __gdshader__("({0} /= {1})", me, other);
	@:op(++A) public static inline function increment(me: Vec3): Vec3 return untyped __gdshader__("(++{0})", me);
	@:op(--A) public static inline function decrement(me: Vec3): Vec3 return untyped __gdshader__("(--{0})", me);
	@:op(A++) public static inline function postIncrement(me: Vec3): Vec3 return untyped __gdshader__("({0}++)", me);
	@:op(A--) public static inline function postDecrement(me: Vec3): Vec3 return untyped __gdshader__("({0}--)", me);
	@:op(A + B) public static inline function addFloatFlipped(other: Float, me: Vec3): Vec3 return untyped __gdshader__("({0} + {1})", other, me);
	@:op(A - B) public static inline function subtractFloatFlipped(other: Float, me: Vec3): Vec3 return untyped __gdshader__("({0} - {1})", other, me);
	@:op(A * B) public static inline function multiplyFloatFlipped(other: Float, me: Vec3): Vec3 return untyped __gdshader__("({0} * {1})", other, me);
	@:op(A / B) public static inline function divideFloatFlipped(other: Float, me: Vec3): Vec3 return untyped __gdshader__("({0} / {1})", other, me);
}
